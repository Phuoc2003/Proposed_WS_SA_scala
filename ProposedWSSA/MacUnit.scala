package ProposedWSSA

import chisel3._


class MacUnit[T <: Data](inputType: T, weightType: T, cType: T, dType: T, fbType: T)() extends RawModule {

  val io = IO(new Bundle {
    val in_a  = Input(inputType)
    val in_b  = Input(weightType)
    val in_c  = Input(cType)
    val sFb = Input(fbType)
    val cFb = Input(fbType)
    val c = Output(SInt(32.W))
    val s = Output(SInt(32.W))
    // If you need a second output, you can add it here, e.g.:
    // val out_s = Output(UInt(32.W))
  })

  val mulS = Wire(SInt(16.W)) 
  val csaC = Wire(SInt(33.W)) 
  val csaS = Wire(SInt(32.W)) 

  val mulInst = Module(new Mul)
  mulInst.a := a
  mulInst.b := b
  mulS := mulInst.prod
  // NOTE: The following statements are auto generated due to the use of concatenation in port-map of instance csa
  //       This default translation is very verbose, you may hence want to refactor it by:
  //          > (TO DO AUTOMATICALLY?) Remove existing wire declaration used in concat {<w1>, <w2>, ...} and rename those wire as <bundleName>.<w1> wherever used.
  //          > Reuse same autogenerated bundle for in and out of extra (use chiselTypeOf())
  val csaB = Cat(Fill(16, mulS(15)), mulS)

  val csa = Module(new Csa(
      width = 32
  ))
  csa.a := sFb.asTypeOf(csa.a)
  csa.b := csaB.asTypeOf(csa.b)
  csa.c := cFb.asTypeOf(csa.c)
  csaC := csa.cOut.asTypeOf(csaC)
  csaS := csa.s.asTypeOf(csaS)
  c := csaC(31,0)
  s := csaS(31,0)
}
