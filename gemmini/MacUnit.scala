package gemmini

import chisel3._
import chisel3.util._
import chisel3.experimental._

class MacUnit[T <: Data](inputType: T, weightType: T, cType: T, dType: T)() extends Module {

    val io = IO(new Bundle {
      val in_a  = Input(inputType)
      val in_b  = Input(weightType)
      val sFb = Input(SInt(32.W))
      val cFb = Input(SInt(32.W))
      val c = Output(SInt(32.W))
      val s = Output(SInt(32.W))
      // If you need a second output, you can add it here, e.g.:
      // val out_s = Output(UInt(32.W))
    })
  
    val mulS = Wire(SInt(16.W)) 
    val csaC = Wire(SInt(33.W)) 
    val csaS = Wire(SInt(32.W)) 
  
    val mulInst = Module(new Mul)
    mulInst.a := io.in_a
    mulInst.b := io.in_b
    mulS := mulInst.prod
    // NOTE: The following statements are auto generated due to the use of concatenation in port-map of instance csa
    //       This default translation is very verbose, you may hence want to refactor it by:
    //          > (TO DO AUTOMATICALLY?) Remove existing wire declaration used in concat {<w1>, <w2>, ...} and rename those wire as <bundleName>.<w1> wherever used.
    //          > Reuse same autogenerated bundle for in and out of extra (use chiselTypeOf())
    val csaB = Cat(Fill(16, mulS(15)), mulS)
  
    val csa = Module(new CSA(
        width = 32
    ))
    csa.a := io.sFb.asTypeOf(csa.a)
    csa.b := csaB.asTypeOf(csa.b)
    csa.c := io.cFb.asTypeOf(csa.c)
    csaC := csa.cout.asTypeOf(csaC)
    csaS := csa.s.asTypeOf(csaS)
    io.c := csaC(31,0).asSInt
    io.s := csaS(31,0).asSInt
  }